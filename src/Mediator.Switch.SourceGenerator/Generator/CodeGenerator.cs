using Mediator.Switch.SourceGenerator.Extensions;
using Microsoft.CodeAnalysis;

namespace Mediator.Switch.SourceGenerator.Generator;

public static class CodeGenerator
{
    public static string Generate(
        ITypeSymbol iRequestType,
        ITypeSymbol iNotificationType,
        List<(ITypeSymbol Class, ITypeSymbol TRequest, ITypeSymbol TResponse, bool HasMediatorRefInCtor)> handlers,
        List<((ITypeSymbol Class, ITypeSymbol TResponse) Request, List<(ITypeSymbol Class, ITypeSymbol TRequest,
            ITypeSymbol TResponse, IReadOnlyList<ITypeParameterSymbol> TypeParameters)> Behaviors)> requestBehaviors,
        List<(ITypeSymbol Class, ITypeSymbol TNotification, bool HasMediatorRefInCtor)> notificationHandlers,
        List<(ITypeSymbol Class, bool HasMediatorRefInCtor)> notifications,
        List<(ITypeSymbol Class, ITypeSymbol TRequest, ITypeSymbol TResponse, IReadOnlyList<ITypeParameterSymbol> TypeParameters)> behaviors)
    {
        // Generate fields
        var handlerFields = handlers.Select(h => $"private readonly {(h.HasMediatorRefInCtor ? $"Lazy<{h.Class}>" : h.Class)} _{h.Class.GetVariableName()};");

        // Generate behavior fields specific to each request, respecting constraints
        var behaviorFields = requestBehaviors.SelectMany(r =>
        {
            var (request, applicableBehaviors) = r;
            return applicableBehaviors.Select(b =>
                $"private readonly {b.Class.ToString().DropGenerics()}<{request.Class}, {b.TResponse}> _{b.Class.GetVariableName()}__{request.Class.GetVariableName()};");
        });
        
        var notificationHandlerFields = notifications.Select(n =>
            $"private readonly IEnumerable<{(n.HasMediatorRefInCtor ? $"Lazy<INotificationHandler<{n.Class}>>" : $"INotificationHandler<{n.Class}>")}> _{n.Class.GetVariableName()}__Handlers;");

        // Generate constructor parameters
        var constructorParams = handlers.Select(h => $"{(h.HasMediatorRefInCtor ? $"Lazy<{h.Class}>" : h.Class)} {h.Class.GetVariableName()}");
        var behaviorParams = requestBehaviors.SelectMany(r =>
        {
            var (request, applicableBehaviors) = r;
            return applicableBehaviors.Select(b =>
                $"{b.Class.ToString().DropGenerics()}<{request.Class}, {b.TResponse}> {b.Class.GetVariableName()}__{request.Class.GetVariableName()}");
        });
        constructorParams = constructorParams.Concat(behaviorParams)
            .Concat(notifications.Select(n => $"IEnumerable<{(n.HasMediatorRefInCtor ? $"Lazy<INotificationHandler<{n.Class}>>" : $"INotificationHandler<{n.Class}>")}> {n.Class.GetVariableName()}__Handlers"));

        // Generate constructor initializers
        var constructorInitializers = handlers.Select(h =>
            $"_{h.Class.GetVariableName()} = {h.Class.GetVariableName()};");
        var behaviorInitializers = requestBehaviors.SelectMany(r =>
        {
            var (request, applicableBehaviors) = r;
            return applicableBehaviors.Select(b =>
                $"_{b.Class.GetVariableName()}__{request.Class.GetVariableName()} = {b.Class.GetVariableName()}__{request.Class.GetVariableName()};");
        });
        constructorInitializers = constructorInitializers.Concat(behaviorInitializers)
            .Concat(notifications.Select(n =>
                $"_{n.Class.GetVariableName()}__Handlers = {n.Class.GetVariableName()}__Handlers;"));

        // Generate Send method switch cases
        var sendCases = requestBehaviors
            .OrderBy(r => r.Request.Class, new TypeHierarchyComparer(iRequestType, requestBehaviors.Select(r => r.Request.Class)))
            .Select(r => TryGenerateSendCase(iRequestType, handlers, r.Request))
            .Where(c => c != null);

        // Generate behavior chain methods
        var behaviorMethods = requestBehaviors
            .Select(r => TryGenerateBehaviorMethod(handlers, r))
            .Where(m => m != null);

        // Generate Publish method switch cases
        var publishCases = notifications
            .OrderBy(n => n.Class, new TypeHierarchyComparer(iRequestType, notifications.Select(n => n.Class)))
            .Select(n => TryGeneratePublishCase(iNotificationType, notificationHandlers, n))
            .Where(c => c != null);
        
        // Generate known types
        var requestHandlerTypes = handlers.Select(h => $"typeof({h.Class})");
        var notificationHandlerTypes = notificationHandlers.Select(h => $"typeof({h.Class})");
        var pipelineBehaviorTypes = behaviors.Select(b => $"typeof({b.Class.ToString().DropGenerics()}<,>)");

        // Generate the complete SwitchMediator class
        return Normalize(
            $$"""
               //------------------------------------------------------------------------------
               // <auto-generated>
               //     This code was generated by SwitchMediator.
               //
               //     Changes to this file may cause incorrect behavior and will be lost if
               //     the code is regenerated.
               // </auto-generated>
               //------------------------------------------------------------------------------
               
               using System;
               using System.Collections.Generic;
               using System.Threading;
               using System.Threading.Tasks;
               
               namespace Mediator.Switch;
               
               #pragma warning disable CS1998

               public class SwitchMediator : IMediator
               {
                   #region Fields
                   
                   {{string.Join("\n    ", handlerFields.Concat(behaviorFields).Concat(notificationHandlerFields))}}
                   
                   #endregion
               
                   #region Constructor
                   
                   public SwitchMediator(
                       {{string.Join(",\n        ", constructorParams)}})
                   {
                       {{string.Join("\n        ", constructorInitializers)}}
                   }
                   
                   #endregion

                   public static (IReadOnlyList<Type> RequestHandlerTypes, IReadOnlyList<Type> NotificationHandlerTypes, IReadOnlyList<Type> PipelineBehaviorTypes) KnownTypes
                   {
                       get { return (SwitchMediatorKnownTypes.RequestHandlerTypes, SwitchMediatorKnownTypes.NotificationHandlerTypes, SwitchMediatorKnownTypes.PipelineBehaviorTypes); }
                   }
                
                   public Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default)
                   {
                       if (SendSwitchCase.Cases.TryGetValue(request.GetType(), out var handle))
                       {
                           return (Task<TResponse>)handle(this, request, cancellationToken);
                       }
                       
                       throw new ArgumentException($"No handler for {request.GetType().Name}");
                   }
                   
                   private static class SendSwitchCase
                   {
                       public static readonly Dictionary<Type, Func<SwitchMediator, object, CancellationToken, object>> Cases = new Dictionary<Type, Func<SwitchMediator, object, CancellationToken, object>>
                       {
               {{string.Join(",\n", sendCases)}}
                       };
                   }
               
                   public Task Publish(INotification notification, CancellationToken cancellationToken = default)
                   {
                       if (PublishSwitchCase.Cases.TryGetValue(notification.GetType(), out var handle))
                       {
                           return handle(this, notification, cancellationToken);
                       }
                       
                       throw new ArgumentException($"No handler for {notification.GetType().Name}");
                   }
                   
                   private static class PublishSwitchCase
                   {
                       public static readonly Dictionary<Type, Func<SwitchMediator, INotification, CancellationToken, Task>> Cases = new Dictionary<Type, Func<SwitchMediator, INotification, CancellationToken, Task>>
                       {
               {{string.Join(",\n", publishCases)}}
                       };
                   }
               
                   {{string.Join("\n\n    ", behaviorMethods)}}
                   
                   /// <summary>
                   /// Provides lists of SwitchMediator component implementation types.
                   /// </summary>
                   public static class SwitchMediatorKnownTypes
                   {
                       public static readonly IReadOnlyList<Type> RequestHandlerTypes =
                           new Type[] {
                               {{string.Join(",\n                ", requestHandlerTypes)}}
                           }.AsReadOnly();
                   
                       public static readonly IReadOnlyList<Type> NotificationHandlerTypes = 
                          new Type[] {
                               {{string.Join(",\n                ", notificationHandlerTypes)}}
                          }.AsReadOnly();
                   
                       public static readonly IReadOnlyList<Type> PipelineBehaviorTypes =
                          new Type[] {
                               {{string.Join(",\n                ", pipelineBehaviorTypes)}}
                          }.AsReadOnly();
                   }    
               }
               """);
    }

    private static string? TryGenerateSendCase(
        ITypeSymbol iRequestType,
        List<(ITypeSymbol Class, ITypeSymbol TRequest, ITypeSymbol TResponse, bool HasMediatorRefInCtor)> handlers,
        (ITypeSymbol Class, ITypeSymbol TResponse) request)
    {
        var current = request.Class;
        do
        {
            var handler = handlers.FirstOrDefault(h =>
                h.TRequest.Equals(current, SymbolEqualityComparer.Default));
            if (handler != default)
            {
                return $$"""
                                     { // case {{request.Class}}:
                                         typeof({{request.Class}}), (instance, request, cancellationToken) =>
                                             instance.Handle_{{current.GetVariableName(false)}}(
                                                 ({{request.Class}}) request, cancellationToken)
                                     }
                         """;
            }
            current = current.BaseType;
        } while (current != null &&
                 current.AllInterfaces.Any(i =>
                     SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, iRequestType)));

        return null;
    }

    private static string? TryGeneratePublishCase(
        ITypeSymbol iNotificationType, 
        List<(ITypeSymbol Class, ITypeSymbol TNotification, bool HasMediatorRefInCtor)> notificationHandlers,
        (ITypeSymbol Class, bool HasMediatorRefInCtor) notification)
    {
        var current = notification.Class;
        do
        {
            var handler = notificationHandlers.FirstOrDefault(h =>
                h.TNotification.Equals(current, SymbolEqualityComparer.Default));
            if (handler != default)
            {
                return $$"""
                                     { // case {{notification.Class}}:
                                         typeof({{notification.Class}}), async (instance, notification, cancellationToken) =>
                                         {
                                             foreach (var handler in instance._{{current.GetVariableName()}}__Handlers)
                                             {
                                                 await handler{{(handler.HasMediatorRefInCtor ? ".Value" : "")}}.Handle(({{notification.Class}})notification, cancellationToken);
                                             }
                                         }
                                     }
                         """;
            }
            current = current.BaseType;
        } while (current != null &&
                 current.AllInterfaces.Any(i =>
                     SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, iNotificationType)));

        return null;
    }

    private static string? TryGenerateBehaviorMethod(List<(ITypeSymbol Class, ITypeSymbol TRequest, ITypeSymbol TResponse, bool HasMediatorRefInCtor)> handlers,
        ((ITypeSymbol Class, ITypeSymbol TResponse) Request, List<(ITypeSymbol Class, ITypeSymbol TRequest, ITypeSymbol TResponse, IReadOnlyList<ITypeParameterSymbol> TypeParameters)> Behaviors) r)
    {
        var (request, applicableBehaviors) = r;
        var handler = handlers.FirstOrDefault(h => h.TRequest.Equals(request.Class, SymbolEqualityComparer.Default));
        if (handler == default) return null;
        var chain = BehaviorChainBuilder.Build(applicableBehaviors, request.Class.GetVariableName(), $"_{handler.Class.GetVariableName()}{(handler.HasMediatorRefInCtor ? ".Value" : "")}.Handle");
        return $$"""
                 private Task<{{request.TResponse}}> Handle_{{request.Class.GetVariableName(false)}}(
                         {{request.Class}} request,
                         CancellationToken cancellationToken)
                     {
                         return
                             {{chain}};
                     }
                 """;
    }

    private static string Normalize(string code) =>
        string.Join("\n",
            code.Replace("\r\n", "\n").TrimEnd().Split('\n')
                .Select(line => line.TrimEnd()));
}